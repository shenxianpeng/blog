---
title: Automating Multi-Dimensional Code Analysis Reports for Git Repositories via Jenkins
summary: This article describes how to use Jenkins to automatically generate multi-dimensional code analysis reports for Git repositories, including manual and scheduled execution methods, helping developers and teams better understand code quality and contribution status.
tags:
  - Stats
  - Git
translate: fase
date: 2020-01-21
author: shenxianpeng
---

In a previous post (GitStats—A Git History Statistics Tool), I provided my boss with Git commit history analysis reports for all the repositories he wanted to see, and deployed the reports to a virtual machine's Tomcat server. My boss can now access and view the analysis reports for each repository via a URL, checking who contributed the most, who was active, who was slacking off, and who was coding on weekends (996 is discouraged here).

Recently, my boss had a request.

_Boss: Why isn't the data on this website updating?  I don't see any of your code commits in the report._
_Me: Boss, you see, the data for each of these repositories was manually generated by me.  Could you give me some time to automate this task?_


My proactive approach wasn't flattery; I knew that if my boss found the Git Stats tool useful, he'd want the analysis reports to be up-to-date. Since he brought it up, I decided to get started right away.

But how to implement it? Jenkins, of course.  First, I've already implemented many automated tasks on Jenkins, so I'm familiar with it. Second, using the same system reduces the number of system entry points, lowers the learning curve, and improves the utilization rate of the Jenkins server.

Considering my boss's needs, he wouldn't want to run a job on the Jenkins server himself to generate these multi-dimensional code analysis reports for the Git repositories.  If I were the boss, I would want:

1. This Jenkins task to run regularly, not too frequently; once a week would be sufficient.
2.  Support for individual execution for a single repository—in case the boss needs to view the analysis report for a specific repository immediately.

The final implementation looks like this:

## Manual Execution

The boss can select the repositories they are most interested in for updating.

## Weekly Scheduled Execution

The boss can see the latest analysis data on Monday morning, showing that the task was "Started by timer".

## The Final Jenkinsfile

```bash
pipeline{
  agent{
    node {
      label 'main-slave'
      customWorkspace "/workspace/gitstats"
    }
  }

  environment {
    USER_CRE = credentials("d1cbab74-823d-41aa-abb7")
    webapproot = "/workspace/apache-tomcat-7.0.99/webapps/gitstats"
  }

  parameters {
    booleanParam(defaultValue: true, name: 'repo1', summary: 'uncheck to disable [repo1]')
    booleanParam(defaultValue: true, name: 'repo2', summary: 'uncheck to disable [repo2]')
  }

  triggers {
    cron '0 3 * * 7'    # Scheduled to run every Sunday morning, when the machine is idle.
  }

  options {
    buildDiscarder(logRotator(numToKeepStr:'10'))
  }

  stages{
    stage("Checkout gitstats"){
      steps{
        # Prepare the directory for storing HTML reports
        sh "mkdir -p html"
        # Download gitstats code
        sh "rm -rf gitstats && git clone https://github.com/hoxu/gitstats.git"
      }
    }
    stage("Under statistics") {
      parallel {
        stage("reop1") {
          when {
            expression { return params.repo1 }  # Check if selected
          }
          steps {
            # Clone the repository to be analyzed (repo1)
            sh 'git clone -b master https://$USER_CRE_USR:"$USER_CRE_PSW"@git.software.com/scm/repo1.git'
            # Analyze the commit history of repo1
            sh "cd gitstats && ./gitstats ../repo1 ../html/repo1"
          }
          post {
            success {
              # If the analysis is successful, move the results to apache-tomcat-7.0.99/webapps/gitstats
              sh 'rm -rf ${webapproot}/repo1 && mv html/repo1 ${webapproot}'
              # Remove repo1 code and HTML report to prevent excessive disk space usage
              sh "rm -rf repo1"
              sh "rm -rf html/repo1"
            }
          }
        }
      }
      stage("repo2") {
          when {
            expression { return params.repo2 }
          }
          steps {
            sh 'git clone -b master https://$USER_CRE_USR:"$USER_CRE_PSW"@git.software.com/scm/repo2.git'
            sh "cd gitstats && ./gitstats ../repo2 ../html/repo2"
          }
          post {
            success {
              sh 'rm -rf ${webapproot}/repo2 && mv html/repo2 ${webapproot}'
              sh "rm -rf repo2"
              sh "rm -rf html/repo2"
            }
          }
        }
      }
    }
  }
  post{
    always{
      # Always send email notification to the executor, and clean the workspace regardless of success or failure
      script {
        def email = load "vars/email.groovy"
        email.build(currentBuild.result, '')
      }
      cleanWs()
    }
  }
}
```

## Conclusion

If you're in testing, DevOps, or R&D efficiency, leveraging open-source tools like Jenkins and Git Stats can quickly provide you (or your boss) with multi-dimensional code analysis reports for Git repositories, helping you better understand the codebase.