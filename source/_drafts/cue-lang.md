---
title: CUE 是一种令人兴奋的配置语言
tags:
  - Go
  - CUE
categories:
  - Go
author: shenxianpeng
date: 2022-04-09 22:34:04
---

你可能已经熟悉 JSON 或 YAML 数据，可能会感到恼火。它可能代表 Kubernetes 服务、API 模式或某种云基础设施。配置数据指定事物的行为或安排方式，这些天有很多。那我的问题是什么？

## 问题

JSON 对机器来说很容易生成或解析，但对我们来说却显得冗长而棘手。YAML 更灵活，但这会使机械解析变得非常困难。公平地说，JSON 是在机器之间交换数据的事实上的标准有线格式，而 YAML 在人机通信方面做得更好。它们都很好，但编写或维护并不完全是一种乐趣。难道我们不应该做得更好吗？

## 我们可以从修复 JSON 开始吗？

由于大多数程序或 API 已经读取和写入 JSON，并且我们选择作为事实来源的任何数据格式都必须等效于某些 JSON，让我们从那里开始。考虑以下 JSON 数据：

```json
{
    "john": {
        "age": 29,
        "hobbies": [
            "physics",
            "reading"
        ]
    }
}
```

这有几件令人讨厌的事情。我们必须提供无用的外花括号，因为 {REASONS}. 我们不允许添加任何评论来解释事物是什么。我们必须引用字段名称，虽然我们必须在数组的最后一个元素之外放置一个逗号 hobbies，但我们同样不能在最后一个元素之后放置一个逗号。这肯定会激怒下一个必须从数组中添加或删除项目的人。

请注意，YAML 在这里也没有通过：虽然它不需要像 JSON 那样多的卷曲样板，但它通过使空白重要来实现这一点。我们还要浪费多少工程师时间痛苦地调整空格和制表符，直到它恰到好处？这种疯狂需要结束。

让我们现在就解决所有这些问题，因为我们手边有魔杖。我们可以这样写：

```json
// John can be grumpy before he's had his coffee.
john: {
    age: 29
    hobbies: [
        "physics",
        "reading",
    ]
}
```

它的可读性不比 JSON 差，而且可写性要高得多。如果机器想要的话，将其转换为等效的 JSON 也很简单。

这是一个好的开始；我们能做更多吗？

## 类型检查

例如，让我们考虑类型。很明显，age 这里是一个数字（确实，它只是一个数字）。类似地，hobbies 是一个字符串数组，稍加思考我们可以看到，不管 john 是什么，他都是某种结构（即结构化数据记录）的一个实例，带有一堆字段。

这些类型是由数据隐含的，但 JSON 中没有任何内容可以让我们实际指定它们。显然，有很多方法可以编写语法正确但语义无效的 JSON：例如，给出一个字符串 for age。

理想的做法是为任何类型的事物编写某种类型的定义 john，包括它的所有字段（模式），我们可以根据它来验证任何给定的数据。也就是说，不仅要检查它的语法，还要确保每个值都是它应该是的类型。这将大大有助于减少我们配置中的错误和问题。

## 类型是值

当然，由于模式只是另一种数据，我们应该能够以与现有数据相同的形式来表达模式。我们可以吗？

```go
#Person: {
  age: number
  hobbies?: [...string]
}
```

我们说有一种结构叫做 #Person（让我们采用 # 命名约定来明确这是一个定义，而不是应该导致一些 JSON 输出的实际数据）。那么 #Person 有一个 age 它是一个数字，并且这个字段是强制性的。

不过，并不是每个人都有爱好，所以我们通过使用尾随 ? 字符 ( hobbies?) 使该字段成为可选字段。如果 hobbies 存在，它必须是字符串列表。

我们已经给出了 john 之前的数据，所以在我们可以自动验证这些数据之前只需要一个步骤：说这 john 是一个 #Person. 到目前为止，我们所做的只是给出两个结构，而没有指定它们之间的任何关系。我们现在可以解决这个问题：

```go
john: #Person
```

## 组合值

john 我们可以将它们组合起来，而不是为写两个单独的值。运营商对此 & 很有意义：

```go
john: #Person & {
    age: 29
    hobbies: [
        "physics",
        "reading",
    ]
}
```

换句话说，john 是 一个 #Person，而他恰好具有这些性质。

机械地检查这两个关于的陈述 john 是否有效，也就是说，是否一致是微不足道的。（我的意思是工程师意义上的“微不足道”，即“在实践中非常复杂，但在某种程度上我们可以轻松应对”。）如果 john 的年龄是一个字符串，或者他 hobbies 的值是 41，或者如果他有一些意想不到的事情字段如 phone，则此数据无效。

同样，我们可以检查数据是否完整：例如，如果我们省略了 John 的年龄，这两个结构将不再匹配，因为 john 是必填字段。这是数据无效的另一种方式，由于我们的定义，我们也可以捕捉到这一点。
#Person #Person.age

（为了对 JSON 严格公平，可以使用 JSON Schema 来做这样的事情，但这远没有我们的“类型就是值”的想法那么优雅，而且还不清楚 JSON 问题的最佳解决方案是更多的 JSON。 )

## 约束

我们正在取得良好的进展，但我们不要止步于此。可能有一致且完整的数据，但在我们需要使用它的上下文中仍然不正确，因为它不符合某些约束。

例如，想象一下人们必须年满 18 岁或以上才能参与某事的情况。我们必须能够 age 按照以下几行来约束场：

```go
#Adult: #Person & {
  age: >=18
}
```

也就是说， 一个 #Adult 是一个 #Person，但不仅如此：它们还必须具有 age 与约束匹配的字段 >=18。

这对于来说是正确的 john，所以我们可以自信地声明：

```go
john: #Adult

// valid
```

但是，如果我们与更年轻的人​​一起尝试，我们希望这不会验证：

```go
anusha: #Adult & {
    age: 17
}

// anusha.age: invalid value 17 (out of bound >=18)
```

如有必要，我们可以编写更复杂的约束表达式。例如：

```go
#WorkingAgePerson: #Person & {
    age: >=16 & <65
}
```

当我们在设计我们梦想的语言时，为什么不也说我们可以以正则表达式的形式对字符串应用约束：

```go
#Phone: string & =~ "[0-9]+"
```

这将要求一个有效 #Phone 的字符串包含至少一个数字。我们可以将 `=~` 运算符理解为“匹配正则表达式”，我们也可以允许逆运算符 `!~`（“不匹配”）。

## 枚举和求和类型

能够将事物限制为一组允许值（这种类型有时称为 enums 或 enumerated types）会很好。

例如，假设我们有一个服务，其中只允许一组特定的用户登录：

```go
#Allowed: "mary" | "leroy" | "abby"
```

要允许用户登录，它必须完全是 "mary"OR "leroy"OR "abby"，仅此而已。

由于类型也是值，我们也可以将某些东西限制为一组类型（程序员会将这种东西称为 sum type）：

```go
#Port: string | int
```

这表示 #Port可以是字符串或整数（但仅此而已）。

## 默认值和参考

如果没有为字段提供特定值，我们希望能够指定默认值：

```go
port: int | *8080
```

此处，*表示如果未另行指定 port 将默认为 8080

就其本身而言，这个单一功能可以消除很多样板。因为相似的事物倾向于共享相似的配置，所以我们永远不需要指定与默认值相同的值。

我们还可以通过简单地引用已经指定的字段，使用其名称来避免重复相同的信息：

```go
port:        6666
ingressPort: port

// ingressPort: 6666
```

在字符串中插入引用也很方便：

```go
port: 8000
url:  "https://localhost:\(port)"

// url: "https://localhost:6666"
```

## 地图

查找表或映射对于减少重复非常方便。实际上，映射只是另一种结构，所以让我们使用相同的语法：

```go
instanceType: {
    web: "small"
    app: "medium"
    db:  "large"
}
```

由于我们已经知道如何按名称引用字段，因此在映射中查找键的工作方式大致相同：

```go
server1: {
    role:     "app"
    instance: instanceType[role]
}

// server1.instance: "medium"
```

当我们的初创公司起飞时，我们需要将所有应用服务器升​​级为 "large" 实例类型，我们不必手动检查每次发生的数据更改。我们可以在地图中更改一次 instanceType，每个服务器都会自动获取更新后的值。

## 生成配置

如果像经常发生的那样，我们有大量具有共同配置的东西，那么应该可以自动生成它们，不是吗？咱们试试吧。

假设我们有三个服务 、a和b，c并且我们希望为每个服务生成一个类似的服务器配置：

```go
for s in ["a", "b", "c"] {
    "www_\(s)": {
        service: s
        role:    "web"
    }
}
```

这为列表中的每个值指定了一个结构 ["a", "b", "c"]（列表推导），我们希望它生成以下 JSON：

```json
{
    "www_a": {
        "service": "a",
        "role": "web"
    },
    "www_b": {
        "service": "b",
        "role": "web"
    },
    "www_c": {
        "service": "c",
        "role": "web"
    }
}
```

如果我们可以从列表中生成数据，我们可能还希望能够通过某些表达式过滤这些列表：

```go
nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
evens: [ for n in nums if mod(n, 2) == 0 {n}]

// evens: [2, 4, 6, 8, 10]
```

这里的 if 子句称为 guard，因为它防止结果中包含不匹配的值。让我们也给自己一些标准函数，例如 mod（整数模数），因为它们一定会派上用场。

## 套餐

说到这，一门优秀的语言需要一个优秀的标准库。让我们包含一组有用的内置包，我们可以为特定作业导入它们，例如列表操作：

```go
import "list"

jumbled: [4, 10, 1, 3, 7, 9, 6, 2, 5, 8]
sorted: list.Sort(jumbled, list.Ascending)

// sorted: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

由于有内置包，我们也应该能够创建自己的用户定义包，方法是在数据文件的顶部添加如下声明：

```go
package person
```

我们现在可以将数据拆分到多个文件中，以便于编辑和协作。只要所有文件都是同一个包的成员，我们就可以将整套文件作为单个配置进行评估。

在考虑包时，我们突然想到我们假设的语言也是它自己的测试框架。为了测试我们的任何代码，我们需要做的就是将预期结果指定为一个值，评估器会告诉我们这是否与实际结果一致：

```go
sorted: list.Sort(jumbled, list.Ascending)
sorted: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// valid
```

## 我们遗漏了什么

看起来我们用很少的额外语法获得了很多特性，这很优雅（甚至令人兴奋）。那么我们没有什么？好吧，我们故意省略了继承（也就是说，不止一层默认值）。我们从 YAML 矿场的痛苦经历中知道，这会很快导致复杂且难以调试的问题。

尽管它很强大，但它仍然只是一种数据语言，而不是成熟的编程语言。这是设计使然；编程语言比我们表达数据所需的功能（因此复杂性）更大。不使用编程语言可以让我们远离最糟糕的麻烦。例如，我们不能编写可能永远不会终止的循环，这意味着，在给定有效数据的情况下，可以保证配置在合理的时间内收敛到一组一致的值。

我们不能做的其他事情是与外界交换数据，例如用户输入、磁盘文件或网络请求。评估的配置是完全可预测和稳定的。这种封闭的数据质量使得检查其正确性变得更加容易，尽管我们可能希望在编写工具时给予自己豁免——例如，自动化配置工作流程，如测试、供应或部署。让我们想象一个特殊的选择加入“脚本模式”，它放宽了这些限制，让我们至少以有限的方式与外界交谈。

## 活出梦想

当然，这是一个美好的梦想，但它真的会发生吗？我们是否注定要终生成为 YAML 工程师或 JSON 管理员？或者有没有办法让这种假设的语言成为现实？

CUE 是一种令人兴奋的配置语言。

读者，我敢说你在两千字前就看到了，它已经是真实的了。该语言称为 CUE（或用于可搜索性的 “cuelang”），你现在可以使用它。本文中的所有示例（包括原始 JSON）都是有效的 CUE，你可以在浏览器中的CUE 操场上试用它们。

尽管它还很年轻，而且发展迅速，但 CUE 已经拥有出色的工具，正如你对受 Go 强烈启发的语言所期望的那样，并且可以从 JSON、JSON Schema、YAML、Protobuf、Go 包和 OpenAPI 模式导入数据。它可以本地导出大多数这些格式的数据，并且你可以通过 CUE 的内置文本模板功能生成你想要的任何格式。例如， Istio 使用 CUE 为 Kubernetes 生成 OpenAPI 和 CRD。

## 我从哪里开始？

那么，假设你对 CUE 感到兴奋，你如何开始使用它来过上最好的生活，并减轻你的 YAML 工程师同事的负担？建议用 CUE 替换所有现有的配置数据可能是不明智的，至少现在是这样，但我们可以更微妙地处理它。如果你愿意，我们可以偷偷做 CUE。

你可以从验证现有配置开始。CUE 可以轻松导入你拥有的所有 YAML 和 JSON，并告诉你其中是否有任何语法错误。可能有，所以你已经赢了。多花点功夫，你可以写一些简单的定义来检查数据是否在语义上也是正确的。

你可以使用 CUE 逐步将策略引入到你的配置中。此外，CUE 数据可以成为你的单一事实来源，你可以简单地从它以所需的任何格式生成所有配置。无需修改你现有的工具：只要它使用 JSON、YAML 或等效工具，我们就可以了。事实上，只要他们得到他们想要的数据，任何人都没有理由知道它是由 CUE 制作的。

正如我们所见，毫无疑问，你还可以通过使用引用、设置默认值和生成配置来减少大量样板文件。也许还有一堆模式你一开始就不必编写，因为 CUE 可以从 Protobuf 文件或 Go 包（例如 Kubernetes）中导入它们。

## 找到更多

以下是一些你可能会觉得有用的资源：

cuelang.org 是 CUE 的官方网站，有很多很棒的文档可供阅读。
官方的 CUE 教程将引导你更详细地了解基本概念。
配置复杂性诅咒很好地概述了这个问题，以及为什么像简单的模板工具这样的东西不是解决方案（以及为什么 CUE 是）。
cuetorials.com 不隶属于 CUE 团队，但提供了一些非常有用的 CUE 示例和模式。
CUE Discussions是 CUE 社区的支持论坛，提供问题、建议、公告等。CUE 团队的 Paul Jolly 和其他人在建立一个友好、热情和包容的社区方面做得很好。

CUE：Go 的数据约束语言和支持是 CUE 的创建者 Marcel van Lohuizen 的精彩演讲，给出了该语言背后的关键思想和一些理论。

Better APIs with Shareable Validation Logic 展示了 CUE 在编写 API 客户端和服务器方面的一些巧妙应用。

使用 CUE 配置 Kubernetes展示了一个使用 CUE 更好地配置 Kubernetes 的示例。

> [CUE is an exciting configuration language](https://bitfieldconsulting.com/golang/cuelang-exciting)
---

转载本站文章请注明作者和出处，请勿用于任何商业用途。欢迎关注公众号「DevOps攻城狮」
